ARM TrustZone Exploitation Suite - Usage

Overview

This repository contains an academic proof-of-concept suite for exploring OP-TEE
and ARM TrustZone behavior on Raspberry Pi 4 hardware. It generates scaffolded
code for hardware scanning, DMA-based proof-of-concept exploits, a fuzzing
framework, and analysis/reporting tools. Many components are educational and
must be adapted to real hardware (see SAFETY and KERNEL REQUIREMENTS below).

WARNING / Safety

- This project contains code that can crash or brick a Raspberry Pi if run with
  root privileges and without proper understanding (DMA writes, /dev/mem,
  privileged execution). Use only on test hardware that can be re-flashed.
- Do NOT run DMA exploit code or hardware scanner on a production device.
- Some operations require kernel modules and elevated privileges.

High-level structure

- `ece595.py` - Master controller; generates helper C templates, fuzzers, and
  analysis tools. Use this to scaffold and run phases.
- `scanners/hardware_scanner.c` (template) - Scanner that maps MMIO and
  collects potential target addresses.
- `exploits/dma_exploit.c` (template) - DMA PoC code (USER-SPACE version is
  only demonstrative; real DMA requires a kernel module).
- `fuzzers/smc_harness.c` (template) - SMC fuzzing harness. NOTE: SMC must
  be invoked from kernel-mode; user-space harness is a template.
- `analysis/crash_analyzer.py` - Crash parsing and reporting utilities.
- `fuzzers/dashboard.html` - Dashboard UI for monitoring fuzzing (simulated).

Quick usage (scaffold only)

1. Generate scaffolding and helper scripts (already done by repo files).
2. Read and edit the generated C templates before compiling.

On host (development machine, not the Pi) you can run:

```bash
# from repository root
python3 ece595.py --phase setup    # creates directories and scaffolding
python3 ece595.py --phase fuzz     # generate fuzz harness & seeds
```

On Raspberry Pi (ONLY after careful review):

- Build and flash OP-TEE and the kernel per OP-TEE build instructions.
- Open a serial console and ensure OP-TEE is running (check dmesg and /dev/tee*).

Compiling examples (on the Pi or cross-compile environment)

```bash
# Compile scanner (example)
cd scanners
gcc -o hardware_scanner hardware_scanner.c -Wall
# Run only on test hardware (with care)
sudo ./hardware_scanner

# Compile exploit template (DEMO ONLY: real exploit must be a kernel module)
cd ../exploits
gcc -o dma_exploit dma_exploit.c -Wall -O2
# DO NOT RUN on production hardware
sudo ./dma_exploit
```

Kernel module / real DMA note (REQUIRED for real attacks)

- To perform correct DMA transfers you must implement a Linux kernel module
  that uses `dma_alloc_coherent()` or DMA API to obtain bus addresses and
  properly aligned, non-cached memory. The user-space templates show the
  control block layout and logic, but passing virtual addresses to the DMA
  controller will not work.
- Likewise, SMC (`smc`) is a privileged instruction and cannot be executed
  from user-space. A kernel module must be used to safely invoke SMC for
  fuzzing or testing.

Testing & Safety checklist

- Use a disposable RPi4 and spare SD card.
- Have a backup image of a working OS and OP-TEE build to re-flash.
- Keep serial console connected and a power-cycle plan.

